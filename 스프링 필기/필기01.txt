──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

@ Maven
-> Maven이란 자바용 프로젝트 관리 도구로, POM(Project Object Model) XML 문서를
통해 해당 프로젝트의 버전 정보 및 라이브러리 정보를 통합하여 관리하는 프레임 워크
-> 일반적인 프로젝트는 개발자가 필요한 라이브러리를 직접 찾아서 추가해야 하지만
Maven을 사용하면 pom.xml 문서에 사용하고자 하는 라이브러리를 등록하여 자동으로 프로젝트에 추가하여 라이브러리 관리의 편의성을 제공해줌

※ 이제 까지 프로젝트내에 있는 lib폴더에 사용 할 라이브러리를 직저 찾아서 추가하고,
관리하였다면 maven에서는 pom.xml 파일 하나만으로 필요한 라이브러리를 자동으로 찾아서 설치하고 관리 할 수 있음

※ POM이란?
-> Project Object Model이라는 뜻으로 하나의 프로젝트에서 사용하는 자바버전,
라이브러리, 플러그인 구성을 통합하여 관리 할 수 있게 각 설정 정보를 XML 파일에
문서화한 것을 의미함

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

메이븐 설치
1. 다운로드 -> http://maven.apache.org/ - apache-maven-3.5.4.zip

2. 압축 풀고 - apache-maven-3.5.4 폴더안에 repository 폴더 생성

3. apache-maven-3.5.4/conf/settings.xml에서 
<!-- localRepository 아래에 <localRepository>C:\apache-maven-3.5.4\repository</localRepository> 경로 추가

4. 이클립스 폴더 내의 eclipse.ini 파일 열어서 -product org.eclipse.epp.package.jee.product 아래에 -vm C:\Program Files\Java\jre1.8.0_144\bin\javaw.exe추가

5. 이클립스 - window - preferences - Maven - user Settings - User Settings(Brose..) 설정한 maven/config 폴더 내의 xml 추가

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────


@ STS란
-> String Tool Suite의 약자로 Spring Framework를 사용하기 위한 개발 툴을 말함
-> 일반적으로 별도의 설치 도구를 통해 설치하나 이클립스 IDE에서 제공하는 STS plug-in을 통해 간단히 설치 할 수 있음
(이클립스 마켓에서 STS 검색 후 설치)

※ STS 공식 설치 사이트
-> https://spring.io/tools/sts/all

※ 스프링 프로젝트 생성 및 설정
-> Spring Legacy Project -> pom.xml -> JAVA 1.6에서 1.8로변경 -> 3.1.1.RELEASE에서 -> 5.0.6.RELEASE으로변경 -> Properties -> 
Project Facets에서 JAVA 1.8로 변경 / Runtimes에서 New.. 클릭후 톰캣 v8.5 추가  -> JSTL오류 발생 시(Tomcat - lib에 JSTL라이브러리 넣음)

※ Welcome 파일 생성 및 등록

1. webapp/index.jsp 생성

2. webapp/web.xml에 추가
<welcome-file-list>
<welcome-file>
index.jsp
</welcome-file>
</welcome-file-list>

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

@ 프레임 워크란?
-> 프레임 워크의 사전적 의미는 뼈대 혹은 틀이라는 뜻을 가지고 있음
-> 어떠한 애플리케이션을 개발 할 때 정해진 것이 없이 개발을 한다면 체계화 되어 있지 않게 되고, 만드는데에도 구조가 정해져 있지 않기 떄문에 시간이 오래 걸리게 됨
-> 프레임워크가 있다면 뼈대(구조)를 프레임워크가 제공해주게 되고 개발 초점에서도 초급개발자, 중급개발자, 고급개발자가 큰 차이 없이 개발을 할 수 있도록 도와줌 
-> 또한 프레임워크로 개발한 애플리케이션의 경우 유지보수가 수월함

@ Spring Framework
-> 스프링 프레임워크는 로드 존슨이 2004년에 만든 오픈소스 프레임 워크
-> 자바 플랫폼을 위한 오픈 소스 애플리케이션 프레임워크로써 스프링(Spring)이라고 부름
-> 동적인 웹 사이트를 개발하기 위한 여러가지 서비스를 제공 하고 있으며, 대한민국 공공기관의 웹 서비스 개발 시 사용을 권장
하고 있는 전자정부 표준 프레임워크의 기반 기술로써 쓰이고 있음
-> 스프링 프레임워크가 등장하기 이전에 자바 기반의 엔터프라이즈 애플리케이션은 대부분 EJB(Enterprise Java Beans)로 개발 되었음
-> EJB 기술은 EJB 컨테이너가 제공하는 많은 기능과 장점이 있음에도 불구하고 개발자들에게 외면 받는 프레임워크

※ Spring 공식 사이트 : https://spring.io/

@ Spring의 특징

1. DI (Dependency Injection / 의존성 주입)
-> 설정 파일이나 어노테이션을 통해 객체간 의존 관계를 설정하여 개발자가 직접 의존하는 객체를 생성 할 필요가 없음
(개발자가 객체 생성을 하지 않고 get 메소드를 통해 객체 생성을 컨테이너로부터 가져옴)

2. Spring AOP (관점 지향 프로그래밍)
-> DataBase의 트랜잭션 처리나 로깅처리와 같이 여러 모듈에서 공통으로 필요로 하는 기능의 경우 해당 기능을 분리하여 관리함

3. Spring JDBC
-> Mybatis나 Hibernate등의 데이터베이스를 처리하는 영속성 프레임워크와 연결할 수 있는 인터페이스를 제공함

4. Spring MVC
-> MVC 디자인 패던을 통해 웹 애플리케이션의 Model, View, Controller 사이의 의존 관계를 DI 컨테이너에서 관리하여 개발자가 아닌 서버가
객체들을 관리하는 웹 애플리케이션을 구축할 수 있음

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

@ Spring IoC
-> Inversion of Control 로써 제어의 역행이라는 뜻을 가지고 있음
-> 프로그램을 구동하는데 필요한 객체에 대한 생성, 변경 등의 관리를
프로그램을 개발하는 사람이 아닌 프로그램을 구동하는데 컨테이너에서 직접 관리하는 것을 말함
-> 스프링은 IoC구조를 통해 구동 시 필요한 객체의 생성부터 생명주기 까지 해당 객체에 대한 관리를 직접 수행 하게 됨

@ IoC 컨테이너의 역할
-> 객체의 생명주기와 의존성을 관리함
	- 생명주기 : 생성 -> 초기화 -> 사용 -> 소멸
	- 의존성 : 개발자가 직접 객체를 생성 할 수 있지만 해당 권한을 컨테이너에
	맡김으로써 소스 코드 구현의 시간을 단축 할 수 있음

@ Spring DI
-> Dependency Injection이란 ioC 구현의 핵심 기술로, 사용하는 객체를 직접 생성하여 만드는 것이 아니라 컨테이너가
빈의 설정 정보를 읽어와 해당 객체에 연결하는 것을 말함
-> 이렇게 의존성을 주입 받게 되면 이후 해당 객체를 수정해야 할 상황이 발생 했을 때 소스 코드의 수정을 최소화 할 수 있음
※ 소스코드에서 new를 이용하여 객체를 만들거나 데이터를 직접적으로 작성하면 객체가 변경되거나 수정해야 할 때 또 다시 코드
수정을 해야 하고 재컴파일 해야 하는 문제가 발생함
이를 이용하면 소스코드를 재수정하고, 재컴파일 하는 경우를 줄일 수 있음

## DI 의 장점 ##
-> 개발자가 작성해야 할 코드가 단순해짐
-> 각 객체간의 종속 관계(결합도)를 해소 할 수 있음

## 객체간의 종속관계 (결합도) ##
-> 한 클래스에서 필드 객체를 생성할 때 발생하는 두 객체간의 관계를 말하며,
각 객체간의 내용이 수정될 경우 영향을 미치는 정도를 뜻 함
-> 예를 들어 A Class에서 B Class를 생성 할 경우, 만약 B Class의 생성자의 매개변수가
변경되거나 제공하는 메소드가 변경될 경우 이를 사용하는 A Class의 일부 정보도 필히 수정해야 하는 상황이 발생하게 되는데
이를 '두 객체간 종속관계(결합도)가 강하다'라고 표현함

※ 결합도가 낮을수록 좋은 코드

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

@ DI의 종류
-> 메소드를 통한 의존성 주입
	- 의존성을 입력받는 일반 메소드를 만들고 이를 통해 의존성을 주입함
	- 팩토리 패턴을 사용하는 방식

-> Setter 메소드를 통한 의존성 주입
	- 의존성을 주입받는 Setter 메소드를 만들고, 이를 통해 의존성을 주입

-> 생성자를 통한 의존성 주입
	- 필요한 의존성을 포함하는 클래스에 생성자를 만들고, 이를 통해 의존성을 주입

## Setter 메소드를 통한 의존성 주입 ##
-> Setter 메소드를 통해 의존관계 있는 Bean을 주입하려면 <property> 태그를 사용함

※ Bean 이란? -> 쉽게 생각하면 자바객체를 Bean 객체라고 함
			 -> 스프링 컨테이너에 의해 만들어진 객체를 Bean이라고 함

# XML 선언 방법 #
<bean id="객체의 이름" class="클래스 풀네임">
	<property name="name" value="OOO" />
	<property name="name" ref="OOO" />
</bean>

-> name 속성은 Class에서 선언한 필드 변수의 이름을 사용
-> value 속성은 단순 값 또는 Bean이 아닌 객체를 주입할 때 사용
-> ref 속성을 사용하면 Bean id를 이용해 주입할 Bean을 찾음

## 생성자를 통한 의존성 주입 ##
-> Constructor를 통해 의존관계가 있는 Bean을 주입하려면 <costructor-arg> 태그를 사용함

# XML 선언 방법 #
<bean id="불러올 객체" class="클래스 풀네임">
	<constructor-arg index="O" value="OOO" />
	<constructor-arg name="OOO" ref="OOO" />
</bean>

-> Constructor 주입방식은 생성자의 파라미터를 이용하기 때문에 한번에 여러 개의 객체를 
주입할 수 있음 
-> 필드 선언 순서에 따라 index 속성을 통해서도 접근이 가능함
-> <constructor-arg> 태그에서 index나 name을 생략하면 해당 클래스의
생성자 매겨변수 순서에 따라 값이 처리 됨

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

@ 스프링 컨테이너의 종류
-> 스프링에서는 BeanFactory와 이를 상속한 ApplicationContext라는 두 가지 유형의
컨테이너를 제공하고 있음
-> 먼저 BeanFactory는 스프링 설정 파일에 등록된 <bean> 객체를 생성하고 관리하는 가장 기본적인 컨테이너 기능만 제공함
-> ApplicationContext는 BeanFactory를 상속 받았으며 <bean> 객체 관리 기능 외에도 트랜잭션 관리나 메세지 기반의 다국어
처리 등 다양한 기능을 제공하고 있음
-> 또한 웹 애플리케이션 개발도 지원하므로 대부분 스프링 프로젝트는 ApplicationConext유형의 컨테이너를 이용함

※ 실제로 ApplicationContext의 구현 클래스는 다양함

## GenericXmlApplicationContext ##
-> 파일 시스템이나 클래스 경로에 있는 XML 설정 파일을 로딩하여 구동하는 컨테이너

## XmlWebApplicationContext ##
-> 웹 기반의 스프링 애플리케이션을 개발 할 때 사용 하는 컨테이너
-> 웹 애플리케이션 개발에서 사용되며, 우리가 직접 생성하진 않음

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

@ 스프링 XML 설정 태그

## <beans> ##
-> 스프링 컨테이너는 <bean> 저장소에 해당하는 XML 설정 파일을 참조하여
<bean>들의 생명주기를 관리하고 여러가지 서비를 제공하고 있음

## <import> 엘리먼트 ##
-> 스프링은 설정 파일(XML) 하나에 우리가 만든 모든 클래스를 <bean>으로 등록하고
관리 할 수 있지만 너무 많은 코드가 하나의 XML 파일에 등록되면 코드 길이가 길어지고 관리자 어려워짐
-> 이 때, XML 파일을 여러개로 나누어 설정 할 수 있음

## scope 속성 ##
-> 프로그램을 개발하다보면 개발자도 모르는 사이에 수많은 객체가 생성 됨
-> 이 중에서 하나만 생성되어도 상관없는 객체들이 있음
-> scope 속성을 이용하면 객체를 sigleton 형태로 만들 것인지 아니면 계속적으로 새롭게 생성할 것인지를 설정 할 수 있음
	- 기본값은 싱글톤, 매번 새롭게 만들 때에는 'prototype' 값을 주면 됨

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

@ 컬렉션 (Collection) 객체 설정
-> 스프링을 개발하다 보면 배열이나 List같은 컬렉션 객체를 이용하여 데이터를
담을 수 있어야 함
-> 이 때, 스프링에서는 컬렉션 매핑과 관련된 엘리먼트를 지원함

## List 타입 매핑 ##
-> 배열 객체나 java.util.List 타입의 컬렉션 객체는 <list>태그를 사용하여 설정함
-> 우선적으로 컬렉션을 맴버변수로 가지는 CollectionBean 클래스 작성하여 사용해야 함

## Set 타입 매핑 ##
-> 중복 값을 허용하지 않는 집합 객체를 사용 할 때에는 Set을 사용하게 되는데 스프링에서는
 Set 컬렉션과의 매핑도 지원함

 ## Map 타입 매핑 ##
 -> 특정 key로 데이터를 등록하고 사용하는 Map 컬렉션과의 매핑을 지원함

 @ DI 어노테이션 방식
 -> 대부분 프레임워크가 그렇듯 스프링 프레임 워크 여시 XML 설정이 매우 중요함
 -> 하지만 반대적으로 XML 파일에 과도한 설정을 하게 되면 내용이 많아지게 되고 관리하기 어려워짐
 -> 따라서 대부분의 프레임워크는 XML 방식 이외에도 어노테이션 방식을 이용한 DI 설정을 지원하고 있음

 ## Context 네임 스페이스 추가 ##
 -> 어노테이션 설정을 추가하려면 <beans>에 Context관련 네임스페이스와 스키마 문서의 위치를 등록 해야함

 ## 컴포넌트 스캔(Compnent-scan) 설정 ##
 -> 스프링 설정 파일에 애플리케이션에서 사용할 객체들을 <bean> 등록하지 않고 자동적으로 생성하려면
 <context:component-scan/> 이라는 엘리먼트를 정의해야함
 -> 이 설정을 추가하면 스프링 컨테이너는 클래스 패스에 있는 클래스들을 스캔하여
 @Component가 설정된 클래스들을 자동으로 객체 생성함
 -> <context:component-scan> 엘리먼트의 base-package 속성 값을
 "org.kh.spring" 형태로 지정하면 org.kh.spring으로 시작하는 모든 패지키들을 스캔 대상으로 포함함

 ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

 XML 방식 

 <bean id="computer" class="org.kh.test.annotation.Computer" />

 Annotation 방식
 해당 클랫의 @Component("computer")를 명시

 객체 생성 시점 
 1. 서버 시작과 동시에 생성
 		- \src\main\webapp\WEB-INF\spring\appServlet\servlet-context.xml 에 스캔 코드를 등록

 2. 서블릿 호출 시 생성
 		- 별도의 XML 파일
 		ex) \src\main\resources\annotationContext.xml 에 스캔 코드를 등록
 		- 이후 GenericXmlApplicationContext를 사용해 읽어 옴

 3. 서버 시작과 동시에 별도의 XML을 불러옴
 		ex) web.xml 파일에 추가

		<init-param>
			<param-name>contextConfigLocation</param-name>
			  <param-value>
			      /WEB-INF/spring/appServlet/servlet-context.xml
			      <!-- 시작시 annotationContext.xml 파일을 읽어옴 -->
				  classpath:annotationContext.xml      
	          </param-value>
		</init-param>

──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────

## @Component ##
-> scan 설정을 했다면 스프링 설정파일에 클래스들을 일일히 <bean> 태그를 이용하여
등록 할 필요가 없음
-> 클래스 선언부 위에 @Component 어노테이션만 추가하면 해당 객체를 만들겠다는 의미가 됨

@ 의존성 주입 설정
-> 스프링에서 의존성 주입을 지원하는 어노테이션으로는 @Autowired, @Inject, @Quallifier, @Resource가 있음

## @Autowired ##
-> 주로 변수 위에 설정하여 해당 타입의 객체를 찾아서 자동으로 할당함

## @Qualifier ##
-> 특정 객체의 이름을 이용하여 의존성 주일 할 때 사용

## @Inject ##
-> @Autowired와 동일한 기능을 지원함(차이점은 Autowired는 스프링 전용, Inject는 자바전용)

## @Resource ##
-> @Autowired와 @Qualifier의 기능을 결합한 어노테이션